https://chromiumcodereview.appspot.com/10332119
https://src.chromium.org/viewvc/chrome?view=rev&revision=136602
https://code.google.com/p/chromium/issues/detail?id=111392
https://code.google.com/p/chromium/issues/detail?id=119903

Index: media/audio/pulse/pulse_output.cc
diff --git a/media/audio/pulse/pulse_output.cc b/media/audio/pulse/pulse_output.cc
index df4b5be979c6937b949f0c9dc8822236b92c6c6a..98f1f58391cd3faf615da999affe4d29a56876c8 100644
--- a/media/audio/pulse/pulse_output.cc
+++ b/media/audio/pulse/pulse_output.cc
@@ -128,7 +128,7 @@ void PulseAudioOutputStream::WriteRequestCallback(pa_stream* playback_handle,
   PulseAudioOutputStream* stream =
       reinterpret_cast<PulseAudioOutputStream*>(stream_addr);
 
-  DCHECK_EQ(stream->manager_->GetMessageLoop(), MessageLoop::current());
+  DCHECK(stream->manager_->GetMessageLoop()->BelongsToCurrentThread());
 
   stream->write_callback_handled_ = true;
 
@@ -138,16 +138,16 @@ void PulseAudioOutputStream::WriteRequestCallback(pa_stream* playback_handle,
 
 PulseAudioOutputStream::PulseAudioOutputStream(const AudioParameters& params,
                                                AudioManagerPulse* manager)
-    : channel_layout_(params.channel_layout),
+    : channel_layout_(params.channel_layout()),
       channel_count_(ChannelLayoutToChannelCount(channel_layout_)),
-      sample_format_(BitsToPASampleFormat(params.bits_per_sample)),
-      sample_rate_(params.sample_rate),
-      bytes_per_frame_(params.channels * params.bits_per_sample / 8),
+      sample_format_(BitsToPASampleFormat(params.bits_per_sample())),
+      sample_rate_(params.sample_rate()),
+      bytes_per_frame_(params.GetBytesPerFrame()),
       manager_(manager),
       pa_context_(NULL),
       pa_mainloop_(NULL),
       playback_handle_(NULL),
-      packet_size_(params.GetPacketSize()),
+      packet_size_(params.GetBytesPerBuffer()),
       frames_per_packet_(packet_size_ / bytes_per_frame_),
       client_buffer_(NULL),
       volume_(1.0f),
@@ -155,7 +155,7 @@ PulseAudioOutputStream::PulseAudioOutputStream(const AudioParameters& params,
       write_callback_handled_(false),
       ALLOW_THIS_IN_INITIALIZER_LIST(weak_factory_(this)),
       source_callback_(NULL) {
-  DCHECK_EQ(manager_->GetMessageLoop(), MessageLoop::current());
+  DCHECK(manager_->GetMessageLoop()->BelongsToCurrentThread());
 
   // TODO(slock): Sanity check input values.
 }
@@ -169,7 +169,7 @@ PulseAudioOutputStream::~PulseAudioOutputStream() {
 }
 
 bool PulseAudioOutputStream::Open() {
-  DCHECK_EQ(manager_->GetMessageLoop(), MessageLoop::current());
+  DCHECK(manager_->GetMessageLoop()->BelongsToCurrentThread());
 
   // TODO(slock): Possibly move most of this to an OpenPlaybackDevice function
   // in a new class 'pulse_util', like alsa_util.
@@ -272,7 +272,7 @@ void PulseAudioOutputStream::Reset() {
 }
 
 void PulseAudioOutputStream::Close() {
-  DCHECK_EQ(manager_->GetMessageLoop(), MessageLoop::current());
+  DCHECK(manager_->GetMessageLoop()->BelongsToCurrentThread());
 
   Reset();
 
@@ -282,7 +282,7 @@ void PulseAudioOutputStream::Close() {
 }
 
 void PulseAudioOutputStream::WaitForWriteRequest() {
-  DCHECK_EQ(manager_->GetMessageLoop(), MessageLoop::current());
+  DCHECK(manager_->GetMessageLoop()->BelongsToCurrentThread());
 
   if (stream_stopped_)
     return;
@@ -337,8 +337,8 @@ void PulseAudioOutputStream::FulfillWriteRequest(size_t requested_bytes) {
   // Request more data from the source until we can fulfill the request or
   // fail to receive anymore data.
   bool buffering_successful = true;
-  while (client_buffer_->forward_bytes() < requested_bytes &&
-         buffering_successful) {
+  size_t forward_bytes = static_cast<size_t>(client_buffer_->forward_bytes());
+  while (forward_bytes < requested_bytes && buffering_successful) {
     buffering_successful = BufferPacketFromSource();
   }
 
@@ -369,7 +369,7 @@ void PulseAudioOutputStream::WriteToStream(size_t bytes_to_write,
   *bytes_written = 0;
   while (*bytes_written < bytes_to_write) {
     const uint8* chunk;
-    size_t chunk_size;
+    int chunk_size;
 
     // Stop writing if there is no more data available.
     if (!client_buffer_->GetCurrentChunk(&chunk, &chunk_size))
@@ -384,7 +384,7 @@ void PulseAudioOutputStream::WriteToStream(size_t bytes_to_write,
 }
 
 void PulseAudioOutputStream::Start(AudioSourceCallback* callback) {
-  DCHECK_EQ(manager_->GetMessageLoop(), MessageLoop::current());
+  DCHECK(manager_->GetMessageLoop()->BelongsToCurrentThread());
   CHECK(callback);
   DLOG_IF(ERROR, !playback_handle_)
       << "Open() has not been called successfully";
@@ -404,19 +404,19 @@ void PulseAudioOutputStream::Start(AudioSourceCallback* callback) {
 }
 
 void PulseAudioOutputStream::Stop() {
-  DCHECK_EQ(manager_->GetMessageLoop(), MessageLoop::current());
+  DCHECK(manager_->GetMessageLoop()->BelongsToCurrentThread());
 
   stream_stopped_ = true;
 }
 
 void PulseAudioOutputStream::SetVolume(double volume) {
-  DCHECK_EQ(manager_->GetMessageLoop(), MessageLoop::current());
+  DCHECK(manager_->GetMessageLoop()->BelongsToCurrentThread());
 
   volume_ = static_cast<float>(volume);
 }
 
 void PulseAudioOutputStream::GetVolume(double* volume) {
-  DCHECK_EQ(manager_->GetMessageLoop(), MessageLoop::current());
+  DCHECK(manager_->GetMessageLoop()->BelongsToCurrentThread());
 
   *volume = volume_;
 }
